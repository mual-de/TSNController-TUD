# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int

class yc_ethernet_source_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_source(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/match/ethernet-match/ethernet-source. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Ethernet source address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'ethernet-source'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'match', 'ethernet-match', 'ethernet-source']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_source/address (yang:mac-address)
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_source/address (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_ethernet_destination_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_destination(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/match/ethernet-match/ethernet-destination. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Ethernet destination address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'ethernet-destination'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'match', 'ethernet-match', 'ethernet-destination']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_destination/address (yang:mac-address)
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_destination/address (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)

  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_ethernet_type_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_type(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/match/ethernet-match/ethernet-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Ethernet frame type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type',)

  _yang_name = 'ethernet-type'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:ether-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'match', 'ethernet-match', 'ethernet-type']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_type/type (l2t:ether-type)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_type/type (l2t:ether-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:ether-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with l2t:ether-type""",
          'defined-type': "l2t:ether-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:ether-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:ether-type', is_config=True)

  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('type', type), ])


class yc_ethernet_match_TNsysrepo__TNflowtable_mastertable_match_ethernet_match(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/match/ethernet-match. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ethernet_source','__ethernet_destination','__ethernet_type',)

  _yang_name = 'ethernet-match'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ethernet_source = YANGDynClass(base=yc_ethernet_source_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_source, is_container='container', yang_name="ethernet-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__ethernet_destination = YANGDynClass(base=yc_ethernet_destination_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_destination, is_container='container', yang_name="ethernet-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__ethernet_type = YANGDynClass(base=yc_ethernet_type_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_type, is_container='container', yang_name="ethernet-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'match', 'ethernet-match']

  def _get_ethernet_source(self):
    """
    Getter method for ethernet_source, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_source (container)

    YANG Description: Ethernet source address.
    """
    return self.__ethernet_source
      
  def _set_ethernet_source(self, v, load=False):
    """
    Setter method for ethernet_source, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_source (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_source() directly.

    YANG Description: Ethernet source address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ethernet_source_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_source, is_container='container', yang_name="ethernet-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_source must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ethernet_source_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_source, is_container='container', yang_name="ethernet-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__ethernet_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_source(self):
    self.__ethernet_source = YANGDynClass(base=yc_ethernet_source_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_source, is_container='container', yang_name="ethernet-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_ethernet_destination(self):
    """
    Getter method for ethernet_destination, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_destination (container)

    YANG Description: Ethernet destination address.
    """
    return self.__ethernet_destination
      
  def _set_ethernet_destination(self, v, load=False):
    """
    Setter method for ethernet_destination, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_destination (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_destination() directly.

    YANG Description: Ethernet destination address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ethernet_destination_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_destination, is_container='container', yang_name="ethernet-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_destination must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ethernet_destination_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_destination, is_container='container', yang_name="ethernet-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__ethernet_destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_destination(self):
    self.__ethernet_destination = YANGDynClass(base=yc_ethernet_destination_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_destination, is_container='container', yang_name="ethernet-destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_ethernet_type(self):
    """
    Getter method for ethernet_type, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_type (container)

    YANG Description: Ethernet frame type.
    """
    return self.__ethernet_type
      
  def _set_ethernet_type(self, v, load=False):
    """
    Setter method for ethernet_type, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match/ethernet_type (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_type() directly.

    YANG Description: Ethernet frame type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ethernet_type_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_type, is_container='container', yang_name="ethernet-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_type must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ethernet_type_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_type, is_container='container', yang_name="ethernet-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__ethernet_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_type(self):
    self.__ethernet_type = YANGDynClass(base=yc_ethernet_type_TNsysrepo__TNflowtable_mastertable_match_ethernet_match_ethernet_type, is_container='container', yang_name="ethernet-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)

  ethernet_source = __builtin__.property(_get_ethernet_source, _set_ethernet_source)
  ethernet_destination = __builtin__.property(_get_ethernet_destination, _set_ethernet_destination)
  ethernet_type = __builtin__.property(_get_ethernet_type, _set_ethernet_type)


  _pyangbind_elements = OrderedDict([('ethernet_source', ethernet_source), ('ethernet_destination', ethernet_destination), ('ethernet_type', ethernet_type), ])


class yc_vlan_id_TNsysrepo__TNflowtable_mastertable_match_vlan_match_vlan_id(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/match/vlan-match/vlan-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: VLAN id.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_id',)

  _yang_name = 'vlan-id'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:vlan-id', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'match', 'vlan-match', 'vlan-id']

  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /TNflowtable/mastertable/match/vlan_match/vlan_id/vlan_id (l2t:vlan-id)
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /TNflowtable/mastertable/match/vlan_match/vlan_id/vlan_id (l2t:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with l2t:vlan-id""",
          'defined-type': "l2t:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:vlan-id', is_config=True)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:vlan-id', is_config=True)

  vlan_id = __builtin__.property(_get_vlan_id, _set_vlan_id)


  _pyangbind_elements = OrderedDict([('vlan_id', vlan_id), ])


class yc_vlan_match_TNsysrepo__TNflowtable_mastertable_match_vlan_match(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/match/vlan-match. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlan_id','__vlan_pcp',)

  _yang_name = 'vlan-match'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_id = YANGDynClass(base=yc_vlan_id_TNsysrepo__TNflowtable_mastertable_match_vlan_match_vlan_id, is_container='container', yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__vlan_pcp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="vlan-pcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:vlan-pcp', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'match', 'vlan-match']

  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /TNflowtable/mastertable/match/vlan_match/vlan_id (container)

    YANG Description: VLAN id.
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /TNflowtable/mastertable/match/vlan_match/vlan_id (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.

    YANG Description: VLAN id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vlan_id_TNsysrepo__TNflowtable_mastertable_match_vlan_match_vlan_id, is_container='container', yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vlan_id_TNsysrepo__TNflowtable_mastertable_match_vlan_match_vlan_id, is_container='container', yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=yc_vlan_id_TNsysrepo__TNflowtable_mastertable_match_vlan_match_vlan_id, is_container='container', yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_vlan_pcp(self):
    """
    Getter method for vlan_pcp, mapped from YANG variable /TNflowtable/mastertable/match/vlan_match/vlan_pcp (l2t:vlan-pcp)

    YANG Description: VLAN priority.
    """
    return self.__vlan_pcp
      
  def _set_vlan_pcp(self, v, load=False):
    """
    Setter method for vlan_pcp, mapped from YANG variable /TNflowtable/mastertable/match/vlan_match/vlan_pcp (l2t:vlan-pcp)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_pcp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_pcp() directly.

    YANG Description: VLAN priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="vlan-pcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:vlan-pcp', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_pcp must be of a type compatible with l2t:vlan-pcp""",
          'defined-type': "l2t:vlan-pcp",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="vlan-pcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:vlan-pcp', is_config=True)""",
        })

    self.__vlan_pcp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_pcp(self):
    self.__vlan_pcp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="vlan-pcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='l2t:vlan-pcp', is_config=True)

  vlan_id = __builtin__.property(_get_vlan_id, _set_vlan_id)
  vlan_pcp = __builtin__.property(_get_vlan_pcp, _set_vlan_pcp)


  _pyangbind_elements = OrderedDict([('vlan_id', vlan_id), ('vlan_pcp', vlan_pcp), ])


class yc_ip_match_TNsysrepo__TNflowtable_mastertable_match_ip_match(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/match/ip-match. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_protocol','__ip_dscp','__ip_ecn',)

  _yang_name = 'ip-match'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_protocol = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)
    self.__ip_dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="ip-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:dscp', is_config=True)
    self.__ip_ecn = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-ecn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'match', 'ip-match']

  def _get_ip_protocol(self):
    """
    Getter method for ip_protocol, mapped from YANG variable /TNflowtable/mastertable/match/ip_match/ip_protocol (uint8)

    YANG Description: IP protocol.
    """
    return self.__ip_protocol
      
  def _set_ip_protocol(self, v, load=False):
    """
    Setter method for ip_protocol, mapped from YANG variable /TNflowtable/mastertable/match/ip_match/ip_protocol (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_protocol() directly.

    YANG Description: IP protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_protocol must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)""",
        })

    self.__ip_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_protocol(self):
    self.__ip_protocol = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)


  def _get_ip_dscp(self):
    """
    Getter method for ip_dscp, mapped from YANG variable /TNflowtable/mastertable/match/ip_match/ip_dscp (inet:dscp)

    YANG Description: IP DSCP (6 bits in ToS field).
    """
    return self.__ip_dscp
      
  def _set_ip_dscp(self, v, load=False):
    """
    Setter method for ip_dscp, mapped from YANG variable /TNflowtable/mastertable/match/ip_match/ip_dscp (inet:dscp)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_dscp() directly.

    YANG Description: IP DSCP (6 bits in ToS field).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="ip-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:dscp', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_dscp must be of a type compatible with inet:dscp""",
          'defined-type': "inet:dscp",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="ip-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:dscp', is_config=True)""",
        })

    self.__ip_dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_dscp(self):
    self.__ip_dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="ip-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:dscp', is_config=True)


  def _get_ip_ecn(self):
    """
    Getter method for ip_ecn, mapped from YANG variable /TNflowtable/mastertable/match/ip_match/ip_ecn (uint8)

    YANG Description: IP ECN (2 bits in ToS field).
    """
    return self.__ip_ecn
      
  def _set_ip_ecn(self, v, load=False):
    """
    Setter method for ip_ecn, mapped from YANG variable /TNflowtable/mastertable/match/ip_match/ip_ecn (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_ecn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_ecn() directly.

    YANG Description: IP ECN (2 bits in ToS field).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-ecn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_ecn must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-ecn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)""",
        })

    self.__ip_ecn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_ecn(self):
    self.__ip_ecn = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-ecn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)

  ip_protocol = __builtin__.property(_get_ip_protocol, _set_ip_protocol)
  ip_dscp = __builtin__.property(_get_ip_dscp, _set_ip_dscp)
  ip_ecn = __builtin__.property(_get_ip_ecn, _set_ip_ecn)


  _pyangbind_elements = OrderedDict([('ip_protocol', ip_protocol), ('ip_dscp', ip_dscp), ('ip_ecn', ip_ecn), ])


class yc_match_TNsysrepo__TNflowtable_mastertable_match(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/match. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_port','__ethernet_match','__vlan_match','__ip_match','__ipv4_source','__ipv4_destination','__udp_source_port','__udp_destination_port','__tcp_source_port','__tcp_destination_port',)

  _yang_name = 'match'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="in-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inv:node-connector-id', is_config=True)
    self.__ethernet_match = YANGDynClass(base=yc_ethernet_match_TNsysrepo__TNflowtable_mastertable_match_ethernet_match, is_container='container', yang_name="ethernet-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__vlan_match = YANGDynClass(base=yc_vlan_match_TNsysrepo__TNflowtable_mastertable_match_vlan_match, is_container='container', yang_name="vlan-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__ip_match = YANGDynClass(base=yc_ip_match_TNsysrepo__TNflowtable_mastertable_match_ip_match, is_container='container', yang_name="ip-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__ipv4_source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4-source", parent=self, choice=('layer-3-match', 'ipv4-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)
    self.__ipv4_destination = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4-destination", parent=self, choice=('layer-3-match', 'ipv4-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)
    self.__udp_source_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="udp-source-port", parent=self, choice=('layer-4-match', 'udp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)
    self.__udp_destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="udp-destination-port", parent=self, choice=('layer-4-match', 'udp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)
    self.__tcp_source_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="tcp-source-port", parent=self, choice=('layer-4-match', 'tcp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)
    self.__tcp_destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="tcp-destination-port", parent=self, choice=('layer-4-match', 'tcp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'match']

  def _get_in_port(self):
    """
    Getter method for in_port, mapped from YANG variable /TNflowtable/mastertable/match/in_port (inv:node-connector-id)
    """
    return self.__in_port
      
  def _set_in_port(self, v, load=False):
    """
    Setter method for in_port, mapped from YANG variable /TNflowtable/mastertable/match/in_port (inv:node-connector-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_port() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="in-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inv:node-connector-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_port must be of a type compatible with inv:node-connector-id""",
          'defined-type': "inv:node-connector-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="in-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inv:node-connector-id', is_config=True)""",
        })

    self.__in_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_port(self):
    self.__in_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="in-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inv:node-connector-id', is_config=True)


  def _get_ethernet_match(self):
    """
    Getter method for ethernet_match, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match (container)
    """
    return self.__ethernet_match
      
  def _set_ethernet_match(self, v, load=False):
    """
    Setter method for ethernet_match, mapped from YANG variable /TNflowtable/mastertable/match/ethernet_match (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_match is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_match() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ethernet_match_TNsysrepo__TNflowtable_mastertable_match_ethernet_match, is_container='container', yang_name="ethernet-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_match must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ethernet_match_TNsysrepo__TNflowtable_mastertable_match_ethernet_match, is_container='container', yang_name="ethernet-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__ethernet_match = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_match(self):
    self.__ethernet_match = YANGDynClass(base=yc_ethernet_match_TNsysrepo__TNflowtable_mastertable_match_ethernet_match, is_container='container', yang_name="ethernet-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_vlan_match(self):
    """
    Getter method for vlan_match, mapped from YANG variable /TNflowtable/mastertable/match/vlan_match (container)
    """
    return self.__vlan_match
      
  def _set_vlan_match(self, v, load=False):
    """
    Setter method for vlan_match, mapped from YANG variable /TNflowtable/mastertable/match/vlan_match (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_match is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_match() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vlan_match_TNsysrepo__TNflowtable_mastertable_match_vlan_match, is_container='container', yang_name="vlan-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_match must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vlan_match_TNsysrepo__TNflowtable_mastertable_match_vlan_match, is_container='container', yang_name="vlan-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__vlan_match = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_match(self):
    self.__vlan_match = YANGDynClass(base=yc_vlan_match_TNsysrepo__TNflowtable_mastertable_match_vlan_match, is_container='container', yang_name="vlan-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_ip_match(self):
    """
    Getter method for ip_match, mapped from YANG variable /TNflowtable/mastertable/match/ip_match (container)
    """
    return self.__ip_match
      
  def _set_ip_match(self, v, load=False):
    """
    Setter method for ip_match, mapped from YANG variable /TNflowtable/mastertable/match/ip_match (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_match is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_match() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ip_match_TNsysrepo__TNflowtable_mastertable_match_ip_match, is_container='container', yang_name="ip-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_match must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ip_match_TNsysrepo__TNflowtable_mastertable_match_ip_match, is_container='container', yang_name="ip-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__ip_match = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_match(self):
    self.__ip_match = YANGDynClass(base=yc_ip_match_TNsysrepo__TNflowtable_mastertable_match_ip_match, is_container='container', yang_name="ip-match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_ipv4_source(self):
    """
    Getter method for ipv4_source, mapped from YANG variable /TNflowtable/mastertable/match/ipv4_source (inet:ipv4-address)

    YANG Description: IPv4 source address.
    """
    return self.__ipv4_source
      
  def _set_ipv4_source(self, v, load=False):
    """
    Setter method for ipv4_source, mapped from YANG variable /TNflowtable/mastertable/match/ipv4_source (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_source() directly.

    YANG Description: IPv4 source address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4-source", parent=self, choice=('layer-3-match', 'ipv4-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_source must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4-source", parent=self, choice=('layer-3-match', 'ipv4-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__ipv4_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_source(self):
    self.__ipv4_source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4-source", parent=self, choice=('layer-3-match', 'ipv4-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)


  def _get_ipv4_destination(self):
    """
    Getter method for ipv4_destination, mapped from YANG variable /TNflowtable/mastertable/match/ipv4_destination (inet:ipv4-address)

    YANG Description: IPv4 destination address.
    """
    return self.__ipv4_destination
      
  def _set_ipv4_destination(self, v, load=False):
    """
    Setter method for ipv4_destination, mapped from YANG variable /TNflowtable/mastertable/match/ipv4_destination (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_destination() directly.

    YANG Description: IPv4 destination address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4-destination", parent=self, choice=('layer-3-match', 'ipv4-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_destination must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4-destination", parent=self, choice=('layer-3-match', 'ipv4-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__ipv4_destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_destination(self):
    self.__ipv4_destination = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv4-destination", parent=self, choice=('layer-3-match', 'ipv4-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)


  def _get_udp_source_port(self):
    """
    Getter method for udp_source_port, mapped from YANG variable /TNflowtable/mastertable/match/udp_source_port (inet:port-number)

    YANG Description: UDP source port.
    """
    return self.__udp_source_port
      
  def _set_udp_source_port(self, v, load=False):
    """
    Setter method for udp_source_port, mapped from YANG variable /TNflowtable/mastertable/match/udp_source_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_udp_source_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_udp_source_port() directly.

    YANG Description: UDP source port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="udp-source-port", parent=self, choice=('layer-4-match', 'udp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """udp_source_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="udp-source-port", parent=self, choice=('layer-4-match', 'udp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)""",
        })

    self.__udp_source_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_udp_source_port(self):
    self.__udp_source_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="udp-source-port", parent=self, choice=('layer-4-match', 'udp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)


  def _get_udp_destination_port(self):
    """
    Getter method for udp_destination_port, mapped from YANG variable /TNflowtable/mastertable/match/udp_destination_port (inet:port-number)

    YANG Description: UDP destination port.
    """
    return self.__udp_destination_port
      
  def _set_udp_destination_port(self, v, load=False):
    """
    Setter method for udp_destination_port, mapped from YANG variable /TNflowtable/mastertable/match/udp_destination_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_udp_destination_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_udp_destination_port() directly.

    YANG Description: UDP destination port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="udp-destination-port", parent=self, choice=('layer-4-match', 'udp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """udp_destination_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="udp-destination-port", parent=self, choice=('layer-4-match', 'udp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)""",
        })

    self.__udp_destination_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_udp_destination_port(self):
    self.__udp_destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="udp-destination-port", parent=self, choice=('layer-4-match', 'udp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)


  def _get_tcp_source_port(self):
    """
    Getter method for tcp_source_port, mapped from YANG variable /TNflowtable/mastertable/match/tcp_source_port (inet:port-number)

    YANG Description: TCP source port.
    """
    return self.__tcp_source_port
      
  def _set_tcp_source_port(self, v, load=False):
    """
    Setter method for tcp_source_port, mapped from YANG variable /TNflowtable/mastertable/match/tcp_source_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcp_source_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcp_source_port() directly.

    YANG Description: TCP source port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="tcp-source-port", parent=self, choice=('layer-4-match', 'tcp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcp_source_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="tcp-source-port", parent=self, choice=('layer-4-match', 'tcp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)""",
        })

    self.__tcp_source_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcp_source_port(self):
    self.__tcp_source_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="tcp-source-port", parent=self, choice=('layer-4-match', 'tcp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)


  def _get_tcp_destination_port(self):
    """
    Getter method for tcp_destination_port, mapped from YANG variable /TNflowtable/mastertable/match/tcp_destination_port (inet:port-number)

    YANG Description: TCP destination port.
    """
    return self.__tcp_destination_port
      
  def _set_tcp_destination_port(self, v, load=False):
    """
    Setter method for tcp_destination_port, mapped from YANG variable /TNflowtable/mastertable/match/tcp_destination_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcp_destination_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcp_destination_port() directly.

    YANG Description: TCP destination port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="tcp-destination-port", parent=self, choice=('layer-4-match', 'tcp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcp_destination_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="tcp-destination-port", parent=self, choice=('layer-4-match', 'tcp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)""",
        })

    self.__tcp_destination_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcp_destination_port(self):
    self.__tcp_destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="tcp-destination-port", parent=self, choice=('layer-4-match', 'tcp-match'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)

  in_port = __builtin__.property(_get_in_port, _set_in_port)
  ethernet_match = __builtin__.property(_get_ethernet_match, _set_ethernet_match)
  vlan_match = __builtin__.property(_get_vlan_match, _set_vlan_match)
  ip_match = __builtin__.property(_get_ip_match, _set_ip_match)
  ipv4_source = __builtin__.property(_get_ipv4_source, _set_ipv4_source)
  ipv4_destination = __builtin__.property(_get_ipv4_destination, _set_ipv4_destination)
  udp_source_port = __builtin__.property(_get_udp_source_port, _set_udp_source_port)
  udp_destination_port = __builtin__.property(_get_udp_destination_port, _set_udp_destination_port)
  tcp_source_port = __builtin__.property(_get_tcp_source_port, _set_tcp_source_port)
  tcp_destination_port = __builtin__.property(_get_tcp_destination_port, _set_tcp_destination_port)

  __choices__ = {'layer-3-match': {'ipv4-match': ['ipv4_source', 'ipv4_destination']}, 'layer-4-match': {'udp-match': ['udp_source_port', 'udp_destination_port'], 'tcp-match': ['tcp_source_port', 'tcp_destination_port']}}
  _pyangbind_elements = OrderedDict([('in_port', in_port), ('ethernet_match', ethernet_match), ('vlan_match', vlan_match), ('ip_match', ip_match), ('ipv4_source', ipv4_source), ('ipv4_destination', ipv4_destination), ('udp_source_port', udp_source_port), ('udp_destination_port', udp_destination_port), ('tcp_source_port', tcp_source_port), ('tcp_destination_port', tcp_destination_port), ])


class yc_output_action_TNsysrepo__TNflowtable_mastertable_action_action_output_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/action/action/output-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__output_port',)

  _yang_name = 'output-action'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__output_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="output-port", parent=self, choice=('action', 'output-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'action', 'action', 'output-action']

  def _get_output_port(self):
    """
    Getter method for output_port, mapped from YANG variable /TNflowtable/mastertable/action/action/output_action/output_port (uint8)
    """
    return self.__output_port
      
  def _set_output_port(self, v, load=False):
    """
    Setter method for output_port, mapped from YANG variable /TNflowtable/mastertable/action/action/output_action/output_port (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_port() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="output-port", parent=self, choice=('action', 'output-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_port must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="output-port", parent=self, choice=('action', 'output-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)""",
        })

    self.__output_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_port(self):
    self.__output_port = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="output-port", parent=self, choice=('action', 'output-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)

  output_port = __builtin__.property(_get_output_port, _set_output_port)

  __choices__ = {'action': {'output-action-case': ['output_port']}}
  _pyangbind_elements = OrderedDict([('output_port', output_port), ])


class yc_drop_action_TNsysrepo__TNflowtable_mastertable_action_action_drop_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/action/action/drop-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__drop_reason',)

  _yang_name = 'drop-action'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__drop_reason = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="drop-reason", parent=self, choice=('action', 'drop-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'action', 'action', 'drop-action']

  def _get_drop_reason(self):
    """
    Getter method for drop_reason, mapped from YANG variable /TNflowtable/mastertable/action/action/drop_action/drop_reason (uint16)
    """
    return self.__drop_reason
      
  def _set_drop_reason(self, v, load=False):
    """
    Setter method for drop_reason, mapped from YANG variable /TNflowtable/mastertable/action/action/drop_action/drop_reason (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_drop_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_drop_reason() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="drop-reason", parent=self, choice=('action', 'drop-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """drop_reason must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="drop-reason", parent=self, choice=('action', 'drop-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint16', is_config=True)""",
        })

    self.__drop_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_drop_reason(self):
    self.__drop_reason = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="drop-reason", parent=self, choice=('action', 'drop-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint16', is_config=True)

  drop_reason = __builtin__.property(_get_drop_reason, _set_drop_reason)

  __choices__ = {'action': {'drop-action-case': ['drop_reason']}}
  _pyangbind_elements = OrderedDict([('drop_reason', drop_reason), ])


class yc_modify_action_TNsysrepo__TNflowtable_mastertable_action_action_modify_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/action/action/modify-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__MAC_DST_overwrite','__MAC_SRC_overwrite','__IPv4_DST_overwrite','__IPv4_SRC_overwrite','__L4_DST_overwrite','__L4_SRC_overwrite',)

  _yang_name = 'modify-action'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__MAC_DST_overwrite = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="MAC-DST-overwrite", parent=self, choice=('modfield', 'MAC-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)
    self.__MAC_SRC_overwrite = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="MAC-SRC-overwrite", parent=self, choice=('modfield', 'MAC-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)
    self.__IPv4_DST_overwrite = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="IPv4-DST-overwrite", parent=self, choice=('modfield', 'IPv4-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)
    self.__IPv4_SRC_overwrite = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="IPv4-SRC-overwrite", parent=self, choice=('modfield', 'IPv4-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)
    self.__L4_DST_overwrite = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="L4-DST-overwrite", parent=self, choice=('modfield', 'L4-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)
    self.__L4_SRC_overwrite = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="L4-SRC-overwrite", parent=self, choice=('modfield', 'L4-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'action', 'action', 'modify-action']

  def _get_MAC_DST_overwrite(self):
    """
    Getter method for MAC_DST_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/MAC_DST_overwrite (yang:mac-address)
    """
    return self.__MAC_DST_overwrite
      
  def _set_MAC_DST_overwrite(self, v, load=False):
    """
    Setter method for MAC_DST_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/MAC_DST_overwrite (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_MAC_DST_overwrite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_MAC_DST_overwrite() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="MAC-DST-overwrite", parent=self, choice=('modfield', 'MAC-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """MAC_DST_overwrite must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="MAC-DST-overwrite", parent=self, choice=('modfield', 'MAC-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__MAC_DST_overwrite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_MAC_DST_overwrite(self):
    self.__MAC_DST_overwrite = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="MAC-DST-overwrite", parent=self, choice=('modfield', 'MAC-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)


  def _get_MAC_SRC_overwrite(self):
    """
    Getter method for MAC_SRC_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/MAC_SRC_overwrite (yang:mac-address)
    """
    return self.__MAC_SRC_overwrite
      
  def _set_MAC_SRC_overwrite(self, v, load=False):
    """
    Setter method for MAC_SRC_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/MAC_SRC_overwrite (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_MAC_SRC_overwrite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_MAC_SRC_overwrite() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="MAC-SRC-overwrite", parent=self, choice=('modfield', 'MAC-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """MAC_SRC_overwrite must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="MAC-SRC-overwrite", parent=self, choice=('modfield', 'MAC-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__MAC_SRC_overwrite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_MAC_SRC_overwrite(self):
    self.__MAC_SRC_overwrite = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="MAC-SRC-overwrite", parent=self, choice=('modfield', 'MAC-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='yang:mac-address', is_config=True)


  def _get_IPv4_DST_overwrite(self):
    """
    Getter method for IPv4_DST_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/IPv4_DST_overwrite (inet:ipv4-address)
    """
    return self.__IPv4_DST_overwrite
      
  def _set_IPv4_DST_overwrite(self, v, load=False):
    """
    Setter method for IPv4_DST_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/IPv4_DST_overwrite (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_IPv4_DST_overwrite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_IPv4_DST_overwrite() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="IPv4-DST-overwrite", parent=self, choice=('modfield', 'IPv4-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """IPv4_DST_overwrite must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="IPv4-DST-overwrite", parent=self, choice=('modfield', 'IPv4-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__IPv4_DST_overwrite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_IPv4_DST_overwrite(self):
    self.__IPv4_DST_overwrite = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="IPv4-DST-overwrite", parent=self, choice=('modfield', 'IPv4-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)


  def _get_IPv4_SRC_overwrite(self):
    """
    Getter method for IPv4_SRC_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/IPv4_SRC_overwrite (inet:ipv4-address)
    """
    return self.__IPv4_SRC_overwrite
      
  def _set_IPv4_SRC_overwrite(self, v, load=False):
    """
    Setter method for IPv4_SRC_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/IPv4_SRC_overwrite (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_IPv4_SRC_overwrite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_IPv4_SRC_overwrite() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="IPv4-SRC-overwrite", parent=self, choice=('modfield', 'IPv4-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """IPv4_SRC_overwrite must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="IPv4-SRC-overwrite", parent=self, choice=('modfield', 'IPv4-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__IPv4_SRC_overwrite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_IPv4_SRC_overwrite(self):
    self.__IPv4_SRC_overwrite = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="IPv4-SRC-overwrite", parent=self, choice=('modfield', 'IPv4-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:ipv4-address', is_config=True)


  def _get_L4_DST_overwrite(self):
    """
    Getter method for L4_DST_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/L4_DST_overwrite (inet:port-number)
    """
    return self.__L4_DST_overwrite
      
  def _set_L4_DST_overwrite(self, v, load=False):
    """
    Setter method for L4_DST_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/L4_DST_overwrite (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_L4_DST_overwrite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_L4_DST_overwrite() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="L4-DST-overwrite", parent=self, choice=('modfield', 'L4-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """L4_DST_overwrite must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="L4-DST-overwrite", parent=self, choice=('modfield', 'L4-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)""",
        })

    self.__L4_DST_overwrite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_L4_DST_overwrite(self):
    self.__L4_DST_overwrite = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="L4-DST-overwrite", parent=self, choice=('modfield', 'L4-DST'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)


  def _get_L4_SRC_overwrite(self):
    """
    Getter method for L4_SRC_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/L4_SRC_overwrite (inet:port-number)
    """
    return self.__L4_SRC_overwrite
      
  def _set_L4_SRC_overwrite(self, v, load=False):
    """
    Setter method for L4_SRC_overwrite, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action/L4_SRC_overwrite (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_L4_SRC_overwrite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_L4_SRC_overwrite() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="L4-SRC-overwrite", parent=self, choice=('modfield', 'L4-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """L4_SRC_overwrite must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="L4-SRC-overwrite", parent=self, choice=('modfield', 'L4-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)""",
        })

    self.__L4_SRC_overwrite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_L4_SRC_overwrite(self):
    self.__L4_SRC_overwrite = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="L4-SRC-overwrite", parent=self, choice=('modfield', 'L4-SRC'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='inet:port-number', is_config=True)

  MAC_DST_overwrite = __builtin__.property(_get_MAC_DST_overwrite, _set_MAC_DST_overwrite)
  MAC_SRC_overwrite = __builtin__.property(_get_MAC_SRC_overwrite, _set_MAC_SRC_overwrite)
  IPv4_DST_overwrite = __builtin__.property(_get_IPv4_DST_overwrite, _set_IPv4_DST_overwrite)
  IPv4_SRC_overwrite = __builtin__.property(_get_IPv4_SRC_overwrite, _set_IPv4_SRC_overwrite)
  L4_DST_overwrite = __builtin__.property(_get_L4_DST_overwrite, _set_L4_DST_overwrite)
  L4_SRC_overwrite = __builtin__.property(_get_L4_SRC_overwrite, _set_L4_SRC_overwrite)

  __choices__ = {'modfield': {'MAC-DST': ['MAC_DST_overwrite'], 'MAC-SRC': ['MAC_SRC_overwrite'], 'IPv4-DST': ['IPv4_DST_overwrite'], 'IPv4-SRC': ['IPv4_SRC_overwrite'], 'L4-DST': ['L4_DST_overwrite'], 'L4-SRC': ['L4_SRC_overwrite']}}
  _pyangbind_elements = OrderedDict([('MAC_DST_overwrite', MAC_DST_overwrite), ('MAC_SRC_overwrite', MAC_SRC_overwrite), ('IPv4_DST_overwrite', IPv4_DST_overwrite), ('IPv4_SRC_overwrite', IPv4_SRC_overwrite), ('L4_DST_overwrite', L4_DST_overwrite), ('L4_SRC_overwrite', L4_SRC_overwrite), ])


class yc_queue_action_TNsysrepo__TNflowtable_mastertable_action_action_queue_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/action/action/queue-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__queue',)

  _yang_name = 'queue-action'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__queue = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="queue", parent=self, choice=('action', 'queue-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'action', 'action', 'queue-action']

  def _get_queue(self):
    """
    Getter method for queue, mapped from YANG variable /TNflowtable/mastertable/action/action/queue_action/queue (uint8)
    """
    return self.__queue
      
  def _set_queue(self, v, load=False):
    """
    Setter method for queue, mapped from YANG variable /TNflowtable/mastertable/action/action/queue_action/queue (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_queue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_queue() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="queue", parent=self, choice=('action', 'queue-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """queue must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="queue", parent=self, choice=('action', 'queue-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)""",
        })

    self.__queue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_queue(self):
    self.__queue = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="queue", parent=self, choice=('action', 'queue-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)

  queue = __builtin__.property(_get_queue, _set_queue)

  __choices__ = {'action': {'queue-action-case': ['queue']}}
  _pyangbind_elements = OrderedDict([('queue', queue), ])


class yc_action_TNsysrepo__TNflowtable_mastertable_action_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/action/action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__order','__output_action','__drop_action','__modify_action','__queue_action',)

  _yang_name = 'action'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__order = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='int32', is_config=True)
    self.__output_action = YANGDynClass(base=yc_output_action_TNsysrepo__TNflowtable_mastertable_action_action_output_action, is_container='container', yang_name="output-action", parent=self, choice=('action', 'output-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__drop_action = YANGDynClass(base=yc_drop_action_TNsysrepo__TNflowtable_mastertable_action_action_drop_action, is_container='container', yang_name="drop-action", parent=self, choice=('action', 'drop-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__modify_action = YANGDynClass(base=yc_modify_action_TNsysrepo__TNflowtable_mastertable_action_action_modify_action, is_container='container', yang_name="modify-action", parent=self, choice=('action', 'modify-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__queue_action = YANGDynClass(base=yc_queue_action_TNsysrepo__TNflowtable_mastertable_action_action_queue_action, is_container='container', yang_name="queue-action", parent=self, choice=('action', 'queue-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'action', 'action']

  def _get_order(self):
    """
    Getter method for order, mapped from YANG variable /TNflowtable/mastertable/action/action/order (int32)
    """
    return self.__order
      
  def _set_order(self, v, load=False):
    """
    Setter method for order, mapped from YANG variable /TNflowtable/mastertable/action/action/order (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_order is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_order() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """order must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='int32', is_config=True)""",
        })

    self.__order = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_order(self):
    self.__order = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='int32', is_config=True)


  def _get_output_action(self):
    """
    Getter method for output_action, mapped from YANG variable /TNflowtable/mastertable/action/action/output_action (container)
    """
    return self.__output_action
      
  def _set_output_action(self, v, load=False):
    """
    Setter method for output_action, mapped from YANG variable /TNflowtable/mastertable/action/action/output_action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_action() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_action_TNsysrepo__TNflowtable_mastertable_action_action_output_action, is_container='container', yang_name="output-action", parent=self, choice=('action', 'output-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_action_TNsysrepo__TNflowtable_mastertable_action_action_output_action, is_container='container', yang_name="output-action", parent=self, choice=('action', 'output-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__output_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_action(self):
    self.__output_action = YANGDynClass(base=yc_output_action_TNsysrepo__TNflowtable_mastertable_action_action_output_action, is_container='container', yang_name="output-action", parent=self, choice=('action', 'output-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_drop_action(self):
    """
    Getter method for drop_action, mapped from YANG variable /TNflowtable/mastertable/action/action/drop_action (container)
    """
    return self.__drop_action
      
  def _set_drop_action(self, v, load=False):
    """
    Setter method for drop_action, mapped from YANG variable /TNflowtable/mastertable/action/action/drop_action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_drop_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_drop_action() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_drop_action_TNsysrepo__TNflowtable_mastertable_action_action_drop_action, is_container='container', yang_name="drop-action", parent=self, choice=('action', 'drop-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """drop_action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_drop_action_TNsysrepo__TNflowtable_mastertable_action_action_drop_action, is_container='container', yang_name="drop-action", parent=self, choice=('action', 'drop-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__drop_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_drop_action(self):
    self.__drop_action = YANGDynClass(base=yc_drop_action_TNsysrepo__TNflowtable_mastertable_action_action_drop_action, is_container='container', yang_name="drop-action", parent=self, choice=('action', 'drop-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_modify_action(self):
    """
    Getter method for modify_action, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action (container)
    """
    return self.__modify_action
      
  def _set_modify_action(self, v, load=False):
    """
    Setter method for modify_action, mapped from YANG variable /TNflowtable/mastertable/action/action/modify_action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modify_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modify_action() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_modify_action_TNsysrepo__TNflowtable_mastertable_action_action_modify_action, is_container='container', yang_name="modify-action", parent=self, choice=('action', 'modify-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modify_action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_modify_action_TNsysrepo__TNflowtable_mastertable_action_action_modify_action, is_container='container', yang_name="modify-action", parent=self, choice=('action', 'modify-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__modify_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modify_action(self):
    self.__modify_action = YANGDynClass(base=yc_modify_action_TNsysrepo__TNflowtable_mastertable_action_action_modify_action, is_container='container', yang_name="modify-action", parent=self, choice=('action', 'modify-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_queue_action(self):
    """
    Getter method for queue_action, mapped from YANG variable /TNflowtable/mastertable/action/action/queue_action (container)
    """
    return self.__queue_action
      
  def _set_queue_action(self, v, load=False):
    """
    Setter method for queue_action, mapped from YANG variable /TNflowtable/mastertable/action/action/queue_action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_queue_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_queue_action() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_queue_action_TNsysrepo__TNflowtable_mastertable_action_action_queue_action, is_container='container', yang_name="queue-action", parent=self, choice=('action', 'queue-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """queue_action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_queue_action_TNsysrepo__TNflowtable_mastertable_action_action_queue_action, is_container='container', yang_name="queue-action", parent=self, choice=('action', 'queue-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__queue_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_queue_action(self):
    self.__queue_action = YANGDynClass(base=yc_queue_action_TNsysrepo__TNflowtable_mastertable_action_action_queue_action, is_container='container', yang_name="queue-action", parent=self, choice=('action', 'queue-action-case'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)

  order = __builtin__.property(_get_order, _set_order)
  output_action = __builtin__.property(_get_output_action, _set_output_action)
  drop_action = __builtin__.property(_get_drop_action, _set_drop_action)
  modify_action = __builtin__.property(_get_modify_action, _set_modify_action)
  queue_action = __builtin__.property(_get_queue_action, _set_queue_action)

  __choices__ = {'action': {'output-action-case': ['output_action'], 'drop-action-case': ['drop_action'], 'modify-action-case': ['modify_action'], 'queue-action-case': ['queue_action']}}
  _pyangbind_elements = OrderedDict([('order', order), ('output_action', output_action), ('drop_action', drop_action), ('modify_action', modify_action), ('queue_action', queue_action), ])


class yc_action_TNsysrepo__TNflowtable_mastertable_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable/action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__action',)

  _yang_name = 'action'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__action = YANGDynClass(base=YANGListType("order",yc_action_TNsysrepo__TNflowtable_mastertable_action_action, yang_name="action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='order', extensions=None), is_container='list', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable', 'action']

  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /TNflowtable/mastertable/action/action (list)
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /TNflowtable/mastertable/action/action (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("order",yc_action_TNsysrepo__TNflowtable_mastertable_action_action, yang_name="action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='order', extensions=None), is_container='list', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("order",yc_action_TNsysrepo__TNflowtable_mastertable_action_action, yang_name="action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='order', extensions=None), is_container='list', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=YANGListType("order",yc_action_TNsysrepo__TNflowtable_mastertable_action_action, yang_name="action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='order', extensions=None), is_container='list', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)

  action = __builtin__.property(_get_action, _set_action)


  _pyangbind_elements = OrderedDict([('action', action), ])


class yc_mastertable_TNsysrepo__TNflowtable_mastertable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable/mastertable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__match','__action',)

  _yang_name = 'mastertable'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)
    self.__match = YANGDynClass(base=yc_match_TNsysrepo__TNflowtable_mastertable_match, is_container='container', yang_name="match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__action = YANGDynClass(base=yc_action_TNsysrepo__TNflowtable_mastertable_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable', 'mastertable']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /TNflowtable/mastertable/id (uint32)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /TNflowtable/mastertable/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)


  def _get_match(self):
    """
    Getter method for match, mapped from YANG variable /TNflowtable/mastertable/match (container)
    """
    return self.__match
      
  def _set_match(self, v, load=False):
    """
    Setter method for match, mapped from YANG variable /TNflowtable/mastertable/match (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_match is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_match() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_match_TNsysrepo__TNflowtable_mastertable_match, is_container='container', yang_name="match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """match must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_match_TNsysrepo__TNflowtable_mastertable_match, is_container='container', yang_name="match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__match = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_match(self):
    self.__match = YANGDynClass(base=yc_match_TNsysrepo__TNflowtable_mastertable_match, is_container='container', yang_name="match", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /TNflowtable/mastertable/action (container)
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /TNflowtable/mastertable/action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_action_TNsysrepo__TNflowtable_mastertable_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_action_TNsysrepo__TNflowtable_mastertable_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=yc_action_TNsysrepo__TNflowtable_mastertable_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  match = __builtin__.property(_get_match, _set_match)
  action = __builtin__.property(_get_action, _set_action)


  _pyangbind_elements = OrderedDict([('id', id), ('match', match), ('action', action), ])


class yc_TNflowtable_TNsysrepo__TNflowtable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNflowtable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data model for TrustNode FlowCache
  """
  __slots__ = ('_path_helper', '_extmethods', '__config_time','__mastertable',)

  _yang_name = 'TNflowtable'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="config_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint64', is_config=True)
    self.__mastertable = YANGDynClass(base=YANGListType("id",yc_mastertable_TNsysrepo__TNflowtable_mastertable, yang_name="mastertable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="mastertable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNflowtable']

  def _get_config_time(self):
    """
    Getter method for config_time, mapped from YANG variable /TNflowtable/config_time (uint64)

    YANG Description: time where flowchange is executed
    """
    return self.__config_time
      
  def _set_config_time(self, v, load=False):
    """
    Setter method for config_time, mapped from YANG variable /TNflowtable/config_time (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_time() directly.

    YANG Description: time where flowchange is executed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="config_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_time must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="config_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint64', is_config=True)""",
        })

    self.__config_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_time(self):
    self.__config_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="config_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint64', is_config=True)


  def _get_mastertable(self):
    """
    Getter method for mastertable, mapped from YANG variable /TNflowtable/mastertable (list)
    """
    return self.__mastertable
      
  def _set_mastertable(self, v, load=False):
    """
    Setter method for mastertable, mapped from YANG variable /TNflowtable/mastertable (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mastertable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mastertable() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_mastertable_TNsysrepo__TNflowtable_mastertable, yang_name="mastertable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="mastertable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mastertable must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_mastertable_TNsysrepo__TNflowtable_mastertable, yang_name="mastertable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="mastertable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)""",
        })

    self.__mastertable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mastertable(self):
    self.__mastertable = YANGDynClass(base=YANGListType("id",yc_mastertable_TNsysrepo__TNflowtable_mastertable, yang_name="mastertable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="mastertable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)

  config_time = __builtin__.property(_get_config_time, _set_config_time)
  mastertable = __builtin__.property(_get_mastertable, _set_mastertable)


  _pyangbind_elements = OrderedDict([('config_time', config_time), ('mastertable', mastertable), ])


class yc_GCL_TNsysrepo__TNtas_ports_GCL(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNtas/ports/GCL. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__timeperiod','__gatestates',)

  _yang_name = 'GCL'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)
    self.__timeperiod = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timeperiod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)
    self.__gatestates = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="gatestates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNtas', 'ports', 'GCL']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /TNtas/ports/GCL/id (uint32)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /TNtas/ports/GCL/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)


  def _get_timeperiod(self):
    """
    Getter method for timeperiod, mapped from YANG variable /TNtas/ports/GCL/timeperiod (uint32)
    """
    return self.__timeperiod
      
  def _set_timeperiod(self, v, load=False):
    """
    Setter method for timeperiod, mapped from YANG variable /TNtas/ports/GCL/timeperiod (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeperiod is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeperiod() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timeperiod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeperiod must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timeperiod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)""",
        })

    self.__timeperiod = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeperiod(self):
    self.__timeperiod = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="timeperiod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)


  def _get_gatestates(self):
    """
    Getter method for gatestates, mapped from YANG variable /TNtas/ports/GCL/gatestates (uint8)
    """
    return self.__gatestates
      
  def _set_gatestates(self, v, load=False):
    """
    Setter method for gatestates, mapped from YANG variable /TNtas/ports/GCL/gatestates (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gatestates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gatestates() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="gatestates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gatestates must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="gatestates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)""",
        })

    self.__gatestates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gatestates(self):
    self.__gatestates = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="gatestates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  timeperiod = __builtin__.property(_get_timeperiod, _set_timeperiod)
  gatestates = __builtin__.property(_get_gatestates, _set_gatestates)


  _pyangbind_elements = OrderedDict([('id', id), ('timeperiod', timeperiod), ('gatestates', gatestates), ])


class yc_ports_TNsysrepo__TNtas_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNtas/ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__GCL','__admin_base_time','__admin_cycle_time_ext','__gate_enable',)

  _yang_name = 'ports'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)
    self.__GCL = YANGDynClass(base=YANGListType("id",yc_GCL_TNsysrepo__TNtas_ports_GCL, yang_name="GCL", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="GCL", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)
    self.__admin_base_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="admin_base_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint64', is_config=True)
    self.__admin_cycle_time_ext = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="admin_cycle_time_ext", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)
    self.__gate_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gate_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNtas', 'ports']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /TNtas/ports/id (uint32)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /TNtas/ports/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)


  def _get_GCL(self):
    """
    Getter method for GCL, mapped from YANG variable /TNtas/ports/GCL (list)
    """
    return self.__GCL
      
  def _set_GCL(self, v, load=False):
    """
    Setter method for GCL, mapped from YANG variable /TNtas/ports/GCL (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_GCL is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_GCL() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_GCL_TNsysrepo__TNtas_ports_GCL, yang_name="GCL", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="GCL", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """GCL must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_GCL_TNsysrepo__TNtas_ports_GCL, yang_name="GCL", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="GCL", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)""",
        })

    self.__GCL = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_GCL(self):
    self.__GCL = YANGDynClass(base=YANGListType("id",yc_GCL_TNsysrepo__TNtas_ports_GCL, yang_name="GCL", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="GCL", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)


  def _get_admin_base_time(self):
    """
    Getter method for admin_base_time, mapped from YANG variable /TNtas/ports/admin_base_time (uint64)
    """
    return self.__admin_base_time
      
  def _set_admin_base_time(self, v, load=False):
    """
    Setter method for admin_base_time, mapped from YANG variable /TNtas/ports/admin_base_time (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_base_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_base_time() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="admin_base_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_base_time must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="admin_base_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint64', is_config=True)""",
        })

    self.__admin_base_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_base_time(self):
    self.__admin_base_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="admin_base_time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint64', is_config=True)


  def _get_admin_cycle_time_ext(self):
    """
    Getter method for admin_cycle_time_ext, mapped from YANG variable /TNtas/ports/admin_cycle_time_ext (uint32)
    """
    return self.__admin_cycle_time_ext
      
  def _set_admin_cycle_time_ext(self, v, load=False):
    """
    Setter method for admin_cycle_time_ext, mapped from YANG variable /TNtas/ports/admin_cycle_time_ext (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_cycle_time_ext is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_cycle_time_ext() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="admin_cycle_time_ext", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_cycle_time_ext must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="admin_cycle_time_ext", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)""",
        })

    self.__admin_cycle_time_ext = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_cycle_time_ext(self):
    self.__admin_cycle_time_ext = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="admin_cycle_time_ext", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint32', is_config=True)


  def _get_gate_enable(self):
    """
    Getter method for gate_enable, mapped from YANG variable /TNtas/ports/gate_enable (boolean)
    """
    return self.__gate_enable
      
  def _set_gate_enable(self, v, load=False):
    """
    Setter method for gate_enable, mapped from YANG variable /TNtas/ports/gate_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gate_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gate_enable() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="gate_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gate_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gate_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='boolean', is_config=True)""",
        })

    self.__gate_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gate_enable(self):
    self.__gate_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="gate_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='boolean', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  GCL = __builtin__.property(_get_GCL, _set_GCL)
  admin_base_time = __builtin__.property(_get_admin_base_time, _set_admin_base_time)
  admin_cycle_time_ext = __builtin__.property(_get_admin_cycle_time_ext, _set_admin_cycle_time_ext)
  gate_enable = __builtin__.property(_get_gate_enable, _set_gate_enable)


  _pyangbind_elements = OrderedDict([('id', id), ('GCL', GCL), ('admin_base_time', admin_base_time), ('admin_cycle_time_ext', admin_cycle_time_ext), ('gate_enable', gate_enable), ])


class yc_TNtas_TNsysrepo__TNtas(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNtas. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data model for TrustNode TAS
  """
  __slots__ = ('_path_helper', '_extmethods', '__ports',)

  _yang_name = 'TNtas'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ports = YANGDynClass(base=YANGListType("id",yc_ports_TNsysrepo__TNtas_ports, yang_name="ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNtas']

  def _get_ports(self):
    """
    Getter method for ports, mapped from YANG variable /TNtas/ports (list)
    """
    return self.__ports
      
  def _set_ports(self, v, load=False):
    """
    Setter method for ports, mapped from YANG variable /TNtas/ports (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ports() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_ports_TNsysrepo__TNtas_ports, yang_name="ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ports must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_ports_TNsysrepo__TNtas_ports, yang_name="ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)""",
        })

    self.__ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ports(self):
    self.__ports = YANGDynClass(base=YANGListType("id",yc_ports_TNsysrepo__TNtas_ports, yang_name="ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='list', is_config=True)

  ports = __builtin__.property(_get_ports, _set_ports)


  _pyangbind_elements = OrderedDict([('ports', ports), ])


class yc_TNconfig_TNsysrepo__TNconfig(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNconfig. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__Ethernet_Switch_enable','__Ethernet_Switch_aging',)

  _yang_name = 'TNconfig'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__Ethernet_Switch_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="Ethernet_Switch_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='boolean', is_config=True)
    self.__Ethernet_Switch_aging = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="Ethernet_Switch_aging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['TNconfig']

  def _get_Ethernet_Switch_enable(self):
    """
    Getter method for Ethernet_Switch_enable, mapped from YANG variable /TNconfig/Ethernet_Switch_enable (boolean)

    YANG Description: enable hardware ethernet switch
    """
    return self.__Ethernet_Switch_enable
      
  def _set_Ethernet_Switch_enable(self, v, load=False):
    """
    Setter method for Ethernet_Switch_enable, mapped from YANG variable /TNconfig/Ethernet_Switch_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_Ethernet_Switch_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_Ethernet_Switch_enable() directly.

    YANG Description: enable hardware ethernet switch
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="Ethernet_Switch_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """Ethernet_Switch_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="Ethernet_Switch_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='boolean', is_config=True)""",
        })

    self.__Ethernet_Switch_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_Ethernet_Switch_enable(self):
    self.__Ethernet_Switch_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="Ethernet_Switch_enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='boolean', is_config=True)


  def _get_Ethernet_Switch_aging(self):
    """
    Getter method for Ethernet_Switch_aging, mapped from YANG variable /TNconfig/Ethernet_Switch_aging (uint8)

    YANG Description: hardware ethernet switch aging time
    """
    return self.__Ethernet_Switch_aging
      
  def _set_Ethernet_Switch_aging(self, v, load=False):
    """
    Setter method for Ethernet_Switch_aging, mapped from YANG variable /TNconfig/Ethernet_Switch_aging (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_Ethernet_Switch_aging is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_Ethernet_Switch_aging() directly.

    YANG Description: hardware ethernet switch aging time
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="Ethernet_Switch_aging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """Ethernet_Switch_aging must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="Ethernet_Switch_aging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)""",
        })

    self.__Ethernet_Switch_aging = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_Ethernet_Switch_aging(self):
    self.__Ethernet_Switch_aging = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="Ethernet_Switch_aging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='uint8', is_config=True)

  Ethernet_Switch_enable = __builtin__.property(_get_Ethernet_Switch_enable, _set_Ethernet_Switch_enable)
  Ethernet_Switch_aging = __builtin__.property(_get_Ethernet_Switch_aging, _set_Ethernet_Switch_aging)


  _pyangbind_elements = OrderedDict([('Ethernet_Switch_enable', Ethernet_Switch_enable), ('Ethernet_Switch_aging', Ethernet_Switch_aging), ])


class TNsysrepo(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module TNsysrepo - based on the path /TNsysrepo. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data model for TrustNode
  """
  __slots__ = ('_path_helper', '_extmethods', '__TNflowtable','__TNtas','__TNconfig',)

  _yang_name = 'config'

  _yang_namespace = 'urn:ietf:params:xml:ns:netconf:base:1.0'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__TNflowtable = YANGDynClass(base=yc_TNflowtable_TNsysrepo__TNflowtable, is_container='container', yang_name="TNflowtable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__TNtas = YANGDynClass(base=yc_TNtas_TNsysrepo__TNtas, is_container='container', yang_name="TNtas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    self.__TNconfig = YANGDynClass(base=yc_TNconfig_TNsysrepo__TNconfig, is_container='container', yang_name="TNconfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_TNflowtable(self):
    """
    Getter method for TNflowtable, mapped from YANG variable /TNflowtable (container)

    YANG Description: Data model for TrustNode FlowCache
    """
    return self.__TNflowtable
      
  def _set_TNflowtable(self, v, load=False):
    """
    Setter method for TNflowtable, mapped from YANG variable /TNflowtable (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_TNflowtable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_TNflowtable() directly.

    YANG Description: Data model for TrustNode FlowCache
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_TNflowtable_TNsysrepo__TNflowtable, is_container='container', yang_name="TNflowtable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """TNflowtable must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_TNflowtable_TNsysrepo__TNflowtable, is_container='container', yang_name="TNflowtable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__TNflowtable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_TNflowtable(self):
    self.__TNflowtable = YANGDynClass(base=yc_TNflowtable_TNsysrepo__TNflowtable, is_container='container', yang_name="TNflowtable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_TNtas(self):
    """
    Getter method for TNtas, mapped from YANG variable /TNtas (container)

    YANG Description: Data model for TrustNode TAS
    """
    return self.__TNtas
      
  def _set_TNtas(self, v, load=False):
    """
    Setter method for TNtas, mapped from YANG variable /TNtas (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_TNtas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_TNtas() directly.

    YANG Description: Data model for TrustNode TAS
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_TNtas_TNsysrepo__TNtas, is_container='container', yang_name="TNtas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """TNtas must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_TNtas_TNsysrepo__TNtas, is_container='container', yang_name="TNtas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__TNtas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_TNtas(self):
    self.__TNtas = YANGDynClass(base=yc_TNtas_TNsysrepo__TNtas, is_container='container', yang_name="TNtas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)


  def _get_TNconfig(self):
    """
    Getter method for TNconfig, mapped from YANG variable /TNconfig (container)
    """
    return self.__TNconfig
      
  def _set_TNconfig(self, v, load=False):
    """
    Setter method for TNconfig, mapped from YANG variable /TNconfig (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_TNconfig is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_TNconfig() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_TNconfig_TNsysrepo__TNconfig, is_container='container', yang_name="TNconfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """TNconfig must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_TNconfig_TNsysrepo__TNconfig, is_container='container', yang_name="TNconfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)""",
        })

    self.__TNconfig = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_TNconfig(self):
    self.__TNconfig = YANGDynClass(base=yc_TNconfig_TNsysrepo__TNconfig, is_container='container', yang_name="TNconfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sysrepo:TrustNode:TNsysrepo', defining_module='TNsysrepo', yang_type='container', is_config=True)

  TNflowtable = __builtin__.property(_get_TNflowtable, _set_TNflowtable)
  TNtas = __builtin__.property(_get_TNtas, _set_TNtas)
  TNconfig = __builtin__.property(_get_TNconfig, _set_TNconfig)


  _pyangbind_elements = OrderedDict([('TNflowtable', TNflowtable), ('TNtas', TNtas), ('TNconfig', TNconfig), ])


